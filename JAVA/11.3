객체 = instance
클래스 = 객체의 타입

생성자 - 객체가 생성될 때 초기화 목적으로 실행되는 메소드
        객체가 생성되는 순간(new)에 자동 호출
        매개 변수의 개수나 타입이 달라야 함
        리턴 타입을 지정할 수 없음
        클래스에 생성자가 하나도 없으면 객체를 생성할 때 자동으로 디폴트 생성자를 넣어줌.
        

생성자의 목적 - 객체 생성 시 초기화

*자바는 캡슐화를 너무 좋아해서 생성자를쓰는걸 좋아함, 생성자가있는게 훨씬 좋은 코드

this - 같은클래스의 다른 생성자 호출
        생성자 내에서만 사용가능, 생성자 코드의 제일 처음에 있어야 함
        this(1,"도넛")    this 생성자 호출 -> radius=1 name=도넛


primitive 데이터 타입 = 기본 데이터 타입 

객체 배열 - 객체에 대한 레퍼런스를 원소로 갖는 배열

circle[] c = new circle[5]
c -> circle 타입의 레퍼런스 값, circle을 가리키는 레퍼런스 방 5개

for(int i=0; i<c.length; i++)
  c[i] = new Circle(i)
배열의 각 원소 객체 생성(여기까지 해야 객체 배열이 완성)


--call by value,reference
자바는 기본적으로 call-by-value -> 값을 복사해서 매개변수를 전달
매개 변수가 레퍼런스타입일때 call-by-reference, 객체를 공유 -> 매개변수로 주소를 전달
배열 레퍼런스도 가능


메소드 오버로딩 -> 리턴 타입은 관련 없음

-객체치환
레퍼런스가 하나도 없는 객체는 가비지객체 라고 한다.

★객체 소멸
new에 의해 할당 받은 객체와 배열 메모리를 자바 가상 기계로 되돌려 주는 행위 -> 소멸된 객체 공간은 재사용가능
★자바에서 사용자 임의로 객체 소멸 안됨
자바는 객체 소멸 연산자 없음(~,delete)
객체 소멸은 자바 가상 기계의 고유한 역할
--------------------------------------------------------------------------------------------------
call-by-value
public class CallByValue {
	static void increase(int m) {
		m+=1;
	}
	public static void main(String[] args) {
		int n = 10;
		increase(n);
		System.out.println(n);
	}
}

call-by-reference
public class CallByReference {
	static void increase(circle m) {
		m.radius++;
	}
	public static void main(String[] args) {
		circle pizza = new circle(10);
		increase(pizza);
		System.out.println(pizza.radius);
	}
}
------------------------
//call-by-reference(배열)
public class ArrayPassing {

	static void increase(int[] array) {
		for(int i=0; i<array.length; i++) {
			array[i]++;
		}
	}
	public static void main(String[] args) {
		int[] a = {9,19,29,39,49};
		increase(a);
		for(int i=0; i<a.length; i++) {
			System.out.print(a[i] + " ");
		}
	}
}
